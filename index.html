<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>أداة الجرد النهائي (نصي) — بدون سيرفر</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Tahoma,Arial,sans-serif;background:#0f172a;color:#e2e8f0;margin:0;padding:2rem}
    .wrap{max-width:980px;margin-inline:auto}
    h1{font-size:1.6rem;margin:.2rem 0 1rem}
    .card{background:#111827;border:1px solid #1f2937;border-radius:16px;padding:1rem 1.25rem;margin:1rem 0;box-shadow:0 10px 25px rgba(0,0,0,.25)}
    label{display:block;margin:.5rem 0 .25rem;color:#cbd5e1}
    input[type=file], textarea, button{width:100%}
    textarea{min-height:240px;background:#0b1220;border:1px solid #1f2937;border-radius:12px;color:#e2e8f0;padding:.75rem}
    input[type=file]{background:#0b1220;border:1px dashed #334155;border-radius:12px;color:#94a3b8;padding:.75rem}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:1rem}
    .btn{background:#2563eb;border:none;border-radius:12px;padding:.9rem 1rem;color:#fff;font-weight:700;cursor:pointer;margin-top:.75rem}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .muted{color:#94a3b8;font-size:.9rem}
    .out{white-space:pre-wrap;background:#0b1220;border:1px solid #1f2937;border-radius:12px;padding:.75rem;min-height:160px}
    .links a{display:inline-block;margin:.5rem .5rem .5rem 0;color:#93c5fd;text-decoration:none;border:1px solid #334155;border-radius:999px;padding:.4rem .75rem}
    .links a:hover{background:#1e293b}
    .hint{font-size:.9rem;color:#a1a1aa}
    .ok{color:#86efac}
    .warn{color:#fca5a5}
    .small{font-size:.85rem;color:#94a3b8}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>أداة الجرد النهائي (إخراج نصي — بدون سيرفر)</h1>
    <p class="muted">ارفع <b>input.txt</b> أو الصق النص مباشرة، ثم اضغط <b>تنفيذ الجرد النهائي</b> لتحصل على ملفي <code>final_inventory.txt</code> و<code>final_inventory_warnings.txt</code>.</p>

    <div class="card">
      <div class="row">
        <div>
          <label>رفع ملف input.txt</label>
          <input id="file" type="file" accept=".txt" />
          <div class="hint">يمكن تركه فارغًا إذا ستستخدم الحقل التالي للصق النص.</div>
        </div>
        <div>
          <label>أو الصق الاستبيانات هنا</label>
          <textarea id="paste" placeholder="الصق الاستبيانات الكبيرة هنا إن لم ترفع ملفًا"></textarea>
        </div>
      </div>
      <button id="run" class="btn" type="button">تنفيذ الجرد النهائي</button>
      <div id="status" class="muted" style="margin-top:.75rem"></div>
      <div class="small">إن واجهت مشكلة، افتح Console في المتصفح لرؤية التفاصيل.</div>
    </div>

    <div class="card">
      <h3 style="margin-top:0">المخرجات المباشرة</h3>
      <div class="row">
        <div>
          <label>final_inventory.txt (للعرض السريع)</label>
          <div id="preview" class="out"></div>
        </div>
        <div>
          <label>التحذيرات</label>
          <div id="warnings" class="out"></div>
        </div>
      </div>
      <div class="links" id="links"></div>
    </div>
  </div>

<script>
document.addEventListener("DOMContentLoaded", () => {
  "use strict";

  // ===== تنظيف محارف التحكم/الاتجاه + التشكيل =====
  const CONTROL_RE = /[\u200C-\u200F\u202A-\u202E\u2066-\u2069]/g;
  const TASHKEEL_RE = /[\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06ED]/g;
  const cleanControls = (s) => (s||"").replace(CONTROL_RE, "");

  const normalizeArabic = (s) => cleanControls(s)
    .replace(TASHKEEL_RE, "")
    .replace(/[إأآٱ]/g,"ا")
    .replace(/ة/g,"ه")
    .replace(/ى/g,"ي")
    .replace(/ؤ/g,"و")
    .replace(/ئ/g,"ي")
    .replace(/ء/g,"")
    .replace(/ـ/g,"")
    .replace(/\s+/g," ")
    .trim()
    .toLowerCase();

  const stripSpaces = (s) => cleanControls(s).replace(/\s+/g," ").trim();

  // ===== جداول القيم =====
  const ALLOWED = new Set(["سيء","جيد جدا","ممتاز","ممتاز جدا"]);
  const NEW_SET = new Set(["جديد","جديده","new"].map(x=>x.toLowerCase()));
  const INTERACTION_POINTS = {"سيء":0,"جيد جدا":3,"ممتاز":4,"ممتاز جدا":6};
  const RESP_POINTS = {"سيء":0,"جيد جدا":1,"ممتاز":2,"ممتاز جدا":4};

  // ===== تطبيع ذكي للتقييمات =====
  const normalizeLabelSmart = (raw) => {
    if (!raw) return "";
    const original = stripSpaces(raw);
    const base = normalizeArabic(original);
    const compact = base.replace(/\s+/g,"");
    const exactMap = {
      "سيء":"سيء","سيئ":"سيء","سئ":"سيء","سي":"سيء",
      "جيدجدا":"جيد جدا","جيد جدا":"جيد جدا","جيدجدأ":"جيد جدا","جيدجدآ":"جيد جدا","جيدجدًا":"جيد جدا","جيد جدًا":"جيد جدا",
      "ممتاز":"ممتاز",
      "ممتازجدا":"ممتاز جدا","ممتاز جدا":"ممتاز جدا","ممتازجدأ":"ممتاز جدا","ممتازجدآ":"ممتاز جدا","ممتازجدًا":"ممتاز جدا","ممتاز جدًا":"ممتاز جدا",
      "جديد":"جديد","جديده":"جديد","new":"جديد"
    };
    if (exactMap[compact]) return exactMap[compact];
    if (compact.startsWith("ممتاز") && (compact.includes("جدا") || compact.includes("جد"))) return "ممتاز جدا";
    if (compact.startsWith("جيد") && (compact.includes("جدا") || compact.includes("جد"))) return "جيد جدا";
    if (compact === "سي" || compact.startsWith("سي")) return "سيء";
    if (compact.startsWith("ممتاز")) return "ممتاز";
    if (compact.startsWith("جديد") || compact === "new") return "جديد";
    return original;
  };

  const hasNoResp = (resp) => {
    if (!resp) return true;
    const t = normalizeArabic(resp);
    const pats = ["لا يوجد","لا توجد","لايوجد","لاوجود","بدون","ما في","مافي"].map(p => normalizeArabic(p));
    return pats.some(p => t.includes(p));
  };

  const pointsToLabel = (total) => {
    if (total >= 9) return "ممتاز جدا";
    if (total >= 7) return "ممتاز";
    if (total >= 4) return "جيد جدا";
    return "سيء";
  };

  const scoreToLabel = (n) => {
    n = Number(n);
    if (!isFinite(n)) return "";
    if (n <= 2) return "سيء";
    if (n <= 6) return "جيد جدا";
    if (n <= 8) return "ممتاز";
    return "ممتاز جدا";
  };

  // ===== التعرف على الأسطر =====
  const isIdLine = (line) => /(الايدي|الايدى|ايدي|اي\s*دي|الاي\s*دي|لايدي|id)/i.test(normalizeArabic(line));
  const parseIdFromLine = (line) => { const m = String(line).match(/-?\d+/); return m ? m[0] : ""; };

  // استخراج الرتبة من السطر (مع/بدون نقطتين)
  const extractRankFromLine = (line) => {
    const n = normalizeArabic(line);
    if (!/(?:^|\s)(?:ال)?رتب(?:ه|ه)?(?:\s+)?(?:(?:ال)?اداري(?:ه|ه))?/.test(n)) return "";
    // بعد آخر نقطتين إن وُجدتا في السطر
    let v = stripSpaces(line.slice(Math.max(line.lastIndexOf(":"), line.lastIndexOf("：")) + 1));
    v = stripSpaces(v.replace(/^[:：]+\s*/, ""));
    if (v) return v;
    // بدون نقطتين: "رتبة ادارية ادفايزر"
    const m = line.match(/(?:^|\s)(?:ال)?رتب(?:ة|ه)?(?:\s+)?(?:(?:ال)?اداري(?:ة|ه))?(?:\s+)(.+)$/i);
    return m ? stripSpaces(m[1]) : "";
  };

  // استخراج الرتبة على مستوى الكتلة كاملة (يتوقف قبل أي مفتاح معروف)
  const extractRankFromBlock = (block) => {
    const keyPattern = "(?:الايدي|لايدي|التقييم\\s+المسؤوليات|التقييم|تقييم|تقيم|المسؤوليات|رتبه|رتبة|الرتبه|الرتبة|تكتات|باند|الباند|فك|النقاط|القبول|مرفوض|تفاعل|id)";
    const re = new RegExp(
      "(?:^|[\\s\\n])(?:ال)?رتب(?:ة|ه)?(?:\\s+)?(?:(?:ال)?اداري(?:ة|ه))?\\s*[:：]?\\s*" +   // المفتاح
      "(.+?)" +                                                                              // القيمة
      "(?=(?:\\s+(?:" + keyPattern + ")\\s*[:：])|\\s*$)",                                   // حتى المفتاح التالي أو نهاية
      "i"
    );
    const m = block.match(re);
    return m ? stripSpaces(m[1]) : "";
  };

  // "التقييم :" (أولوية قصوى) و "تفاعل القسم :" (Fallback)
  const isEvalStrictLine = (line) => {
    const n = normalizeArabic(line);
    return /(التقييم|تقييم|تقيم)\s*:/.test(n) && !/(مسؤول|مسئول|مسوول)/.test(n);
  };
  const isInteractionLine = (line) => /تفاعل القسم\s*:/.test(normalizeArabic(line));

  // تقييم المسؤوليات + "المسؤوليات لايوجد" مع/بدون نقطتين
  const isRespEvalLine = (line) => {
    const n = normalizeArabic(line);
    return /(التقييم|تقييم|تقيم)/.test(n) && /(مسؤول|مسئول|مسوول)/.test(n) && /:/.test(n);
  };
  const isRespNoneLine = (line) => {
    const n = normalizeArabic(line);
    return /^المسؤوليات(?:\s*:)?\s*(لايوجد|لا يوجد|بدون|مافي)\s*$/.test(n);
  };

  const getValueAfterLastColon = (line) => {
    const i1 = line.lastIndexOf("：");
    const i2 = line.lastIndexOf(":");
    const idx = Math.max(i1, i2);
    if (idx >= 0) return stripSpaces(line.slice(idx+1));
    const m = line.match(/[—\-]\s*(.+)$/);
    return m ? stripSpaces(m[1]) : "";
  };

  // ===== تقسيم النص =====
  const splitIntoBlocks = (text) => {
    const t = cleanControls(text).replace(/\r\n/g,"\n");
    let chunks = t.split(/^\s*(?:={3,}|-{3,})\s*$/m).map(s=>s.trim()).filter(Boolean);
    if (chunks.length > 1) return chunks;
    const lines = t.split("\n");
    const starts = [];
    for (let i=0;i<lines.length;i++){
      if (isIdLine(lines[i]) && parseIdFromLine(lines[i])) starts.push(i);
    }
    if (starts.length === 0) return [t.trim()];
    const blocks = [];
    for (let k=0;k<starts.length;k++){
      const s = starts[k];
      const e = (k+1<starts.length) ? starts[k+1] : lines.length;
      blocks.push(lines.slice(s,e).join("\n").trim());
    }
    return blocks;
  };

  // ===== استخراج الحقول =====
  const parseBlock = (block, warnings) => {
    const lines = block.split(/\n/);
    let id="", rank="", evalStrict="", evalFromInteractionRaw="", respLabel="", respNone=false;

    for (const ln of lines){
      try{
        if (!id && isIdLine(ln)) { id = parseIdFromLine(ln) || getValueAfterLastColon(ln); continue; }
        if (!rank) {
          const rLine = extractRankFromLine(ln);
          if (rLine) { rank = rLine; continue; }
        }
        if (!evalStrict && isEvalStrictLine(ln)) { evalStrict = normalizeLabelSmart(getValueAfterLastColon(ln)); continue; }
        if (!evalFromInteractionRaw && isInteractionLine(ln)) { evalFromInteractionRaw = stripSpaces(getValueAfterLastColon(ln)); continue; }
        if (!respLabel && isRespEvalLine(ln)) { respLabel = normalizeLabelSmart(getValueAfterLastColon(ln)); continue; }
        if (!respNone && isRespNoneLine(ln)) { respNone = true; continue; }
      }catch(e){ /* تجاهل */ }
    }

    // Fallback للايدي
    if (!id) {
      const m = block.match(/(?:الايدي|الايدى|ايدي|اي\s*دي|الاي\s*دي|لايدي|id)\s*[:：]?\s*([\-]?\d+)/i);
      if (m) { id = m[1]; warnings.push(`[${id}] ℹ️ تم استخراج الايدي عبر Fallback (مطابقة عامة داخل الكتلة).`); }
      else {
        const n = block.match(/-?\d+/);
        if (n) { id = n[0]; warnings.push(`[${id}] ℹ️ لم يُعثر على مفتاح الايدي، تم استخدام أول رقم في الكتلة كـ ID.`); }
      }
    }

    // Fallback للرتبة على مستوى الكتلة (إذا لم تُلتقط من سطر)
    if (!rank) {
      const rBlk = extractRankFromBlock(block);
      if (rBlk) rank = rBlk;
    }

    // Fallback شامل للعثور على "التقييم :" إذا لم يُلتقط كسطر
    if (!evalStrict) {
      const mEval = block.match(/^\s*(?:التقييم|تقييم|تقيم)\s*[:：]\s*([^\n\r]+)/mi);
      if (mEval) evalStrict = normalizeLabelSmart(mEval[1]);
    }

    // تحويل "تفاعل القسم : [n]" إلى وسم تقييم عند غياب "التقييم :"
    let evalFromInteraction = "";
    if (!evalStrict && evalFromInteractionRaw) {
      const num = (evalFromInteractionRaw.match(/\d+/)||[])[0];
      if (num !== undefined) evalFromInteraction = scoreToLabel(num);
      else evalFromInteraction = normalizeLabelSmart(evalFromInteractionRaw);
    }

    let respFinal = respLabel;
    if (respNone && !respFinal) respFinal = "لا يوجد";

    return {
      id: stripSpaces(id),
      rank: stripSpaces(rank),
      evalLabel: normalizeLabelSmart(evalStrict || evalFromInteraction || ""),
      respLabel: normalizeLabelSmart(respFinal)
    };
  };

  // ===== القواعد (تشمل "جديد") =====
  const computeFinal = (evalLabelIn, respLabelIn, warnings, id) => {
    const evalLabel = normalizeLabelSmart(evalLabelIn);
    const respLabel = normalizeLabelSmart(respLabelIn);

    if (evalLabel === "جديد" && respLabel === "جديد") return "جديد";
    if (evalLabel === "جديد") return "جديد";

    const respUnknownOrNew = (!respLabel) || hasNoResp(respLabel) || respLabel === "جديد" || !ALLOWED.has(respLabel);
    if (respUnknownOrNew) {
      if (!ALLOWED.has(evalLabel)) {
        warnings.push(`[${id||"?"}] ⚠️ تقييم غير معروف للتفاعل: '${evalLabelIn}' → تم افتراض 'سيء'`);
        return "سيء";
      }
      return evalLabel;
    }

    if (!ALLOWED.has(evalLabel)) {
      warnings.push(`[${id||"?"}] ⚠️ تقييم غير معروف للتفاعل: '${evalLabelIn}' → يعامل كـ 'سيء' (0 نقطة)`);
    }
    const interP = INTERACTION_POINTS[ALLOWED.has(evalLabel) ? evalLabel : "سيء"] ?? 0;
    const respP  = RESP_POINTS[respLabel] ?? 0;
    return pointsToLabel(interP + respP);
  };

  const toFinalBlock = (rec) =>
    `الايدي : ${rec.id}\n\nالرتبة الادارية : ${rec.rank}\n\nألتقييم : ${rec.final}\n\n-----\n`;

  // ===== UI =====
  const $ = (id) => document.getElementById(id);
  const fileInput = $("file");
  const pasteArea = $("paste");
  const runBtn = $("run");
  const status = $("status");
  const preview = $("preview");
  const warningsBox = $("warnings");
  const links = $("links");

  const readFileText = (file) => new Promise((res, rej) => {
    const fr = new FileReader();
    fr.onload = () => res(String(fr.result || ""));
    fr.onerror = rej;
    fr.readAsText(file, "utf-8");
  });

  const downloadText = (filename, text) => {
    const blob = new Blob([text], {type:"text/plain;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 120);
    return url;
  };

  runBtn?.addEventListener("click", async () => {
    try{
      runBtn.disabled = true;
      status.innerHTML = "جارٍ المعالجة...";
      preview.textContent = "";
      warningsBox.textContent = "";
      links.innerHTML = "";

      let inputText = "";
      if (fileInput?.files && fileInput.files[0]) inputText = await readFileText(fileInput.files[0]);
      else inputText = pasteArea?.value || "";
      if (!inputText.trim()){ status.innerHTML = '<span class="warn">لم يتم إدخال أي نص.</span>'; return; }

      const blocks = splitIntoBlocks(inputText);
      const warnings = [];
      const outputs = [];

      for (const block of blocks){
        try{
          const data = parseBlock(block, warnings);
          if (!data.id) { warnings.push("[?] ⚠️ لم يتم العثور على الايدي داخل هذه الكتلة. تم تجاهلها."); continue; }
          if (!data.evalLabel) { warnings.push(`[${data.id}] ⚠️ لا يوجد حقل 'التقييم'. تم افتراض 'سيء'.`); }
          const evalL = data.evalLabel || "سيء";
          const finalLabel = computeFinal(evalL, data.respLabel, warnings, data.id);
          outputs.push(toFinalBlock({id: data.id, rank: data.rank, final: finalLabel}));
        }catch(e){
          console.error("Block parse error:", e);
          warnings.push("[?] ⚠️ فشل تحليل كتلة معينة بسبب خطأ غير متوقع.");
        }
      }

      const finalTxt = outputs.join("");
      const warnTxt = (warnings.length ? warnings.join("\n") : "لا توجد تحذيرات. تمت معالجة جميع السجلات بنجاح.");

      preview.textContent = finalTxt || "(لا توجد نتائج)";
      warningsBox.textContent = warnTxt;

      const url1 = downloadText("final_inventory.txt", finalTxt);
      const url2 = downloadText("final_inventory_warnings.txt", warnTxt);

      links.innerHTML =
        `<a href="${url1}" target="_blank" rel="noopener">عرض سريع: final_inventory.txt</a>
         <a href="${url2}" target="_blank" rel="noopener">عرض سريع: final_inventory_warnings.txt</a>`;

      status.innerHTML = '<span class="ok">تم إنشاء الملفين بنجاح.</span>';
    } catch(err){
      console.error(err);
      status.innerHTML = '<span class="warn">حدث خطأ أثناء المعالجة. راجع Console.</span>';
    } finally {
      runBtn.disabled = false;
    }
  });

});
</script>
</body>
</html>
